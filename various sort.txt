정렬에 대해 복습하는 시간이다.
우선 삽입정렬을 python으로 다시 만들어 보았다.
어색했던것은 변수를 선언하는 부분부터 였는데, 크기가 0인 배열을 취급하는 법이 python과 c++에 차이점을 느꼈다.
C++로 만들었을 당시에는 삽입정렬 특성상 정렬된 배열을 저장할 공간이 필요한데, 정렬되지 않은 배열의 원소와 비교하는 과정에서 크기가 0인 배열의 원소와 비교하는 경우에 문제가 생길수 밖에 없었다.
그래서 크기가 0인 경우에는 일단 배열에 넣고 나서 그 이후부터 비교를 하며 정렬을 하도록 만들었는데
python의 경우 append를 사용하여 크기가 0인 경우에도 무리없이 정렬을 진행할수 있었던 것 같다.
다음에 해보고 싶은 것은 modify sort인데, 중간점을 찾는 것이 아닌 시작점과 끝점을 찾는 방법을 쓴다면 이전에 맞이했던 정렬이 원하는대로 안되던 문제를 극복할수 있을것 같다.
----------------------------------------11.20---------------------------------------------------
modify sort를 python으로 다시 만드는 과정에 있다.
삽입 정렬과 이진탐색을 다시 만드는 것은 크게 어렵지 않았다.
둘을 합치는 것은 삽입 정렬 과정에서 만들어지는 새로운 배열에 이진 탐색을 해서 올바른 위치를 찾아 정렬하는 것인데
이진 탐색에서 의문이 생겼다.
반환 값이 최종 중간값인데, 맨 앞과 맨 뒷값은 원하는 값이 반환되지 않았다.
이진 탐색 함수 내에서 탈출 조건이 L 이 R보다 같거나 커지는 시점이 원인인것 같다.
----------------------------------------11.20.-------------------------------------------------
이진탐색에서 문제가 되는 상황을 찾았다.
기존에는 StartP 가 EndP 와 같거나 커지는 경우에 반복문을 탈출하도록 했었다.
그 경우 찾고자 하는 값이 배열에 존재함에도 불구하고 찾을수 없는 경우가 존재했다.
그 이유는 조건에 의해 탈출하면서 Mid 값을 갱신하지 않았기 때문이었다.
do while 기능이 있었다면 달랐을지도 모르겠다.
Mid 값 갱신을 위해서 StartP 가 EndP 보다 커지는 경우에 탈출하도록 바꾸었다.
그 결과, 배열에 존재하는 값을 찾을수 있었다.
다음으로 나타난 문제점은 바로 존재하지 않는 값의 올바른 위치를 찾는데 일부 값이 올바른 위치를 찾아가지 못하는 경우 였다.
원인은 역시나 Mid 값 갱신에 있었는데, StartP 값이 EndP 값보다 커지는 경우 Mid 값은 StartP 값과 같도록 만들어 해결할수 있었다.
써놓고 보니, 위에 써놓은 두 상황을 반복문 내에서 같이 해결할수 있을것 처럼 느껴진다.
이렇게 이진탐색을 보완할수 있었고, 입력된 숫자를 배치할 올바른 위치를 찾을수 있었다.
이것을 modify sort 내부에 집어넣었고, 해당 위치에 insert 를 하였다.
insert 기능에 내가 미치 알지 못했던 것을 알게 되었는데
insert 할 배열의 전체 크기보다 큰 index 위치에 삽입해도 내가 의도한 위치에 삽입된다는 것이었다.
그러니까 insert 와 append 는 어떻게 보면 같은 기능이었던 것이다.
insert와 push_back 또한 그런지 알아보고 싶어졌다.
그렇게 modify sort를 일단 완성할수 있었다.
마지막으로, insert sort 와 modify sort를 비교해 보았다.
결과로 내놓은 정렬된 배열은 같았다.
둘다 정렬을 의도한대로 잘 해준 모양이다.
둘의 속도를 비교하기 위해 loopcount 를 세어보고, 출력하도록 했는데
시간 차이가 확연히 드러났다.
heap sort 또한 nlogn 의 속도라고 들었는데 언젠가 만들어보고 속도를 비교하고 싶어졌다.